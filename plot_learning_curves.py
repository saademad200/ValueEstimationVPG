#!/usr/bin/env python3
"""
Plot timesteps vs reward for VPG and PPO from WandB runs.
Creates learning curves like the paper's figures.
"""

import argparse
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from pathlib import Path
import wandb

# Set style
plt.style.use('seaborn-v0_8-whitegrid')


def fetch_wandb_runs(project: str, entity: str, filters: dict = None):
    """Fetch runs from WandB."""
    api = wandb.Api()
    runs = api.runs(f"{entity}/{project}", filters=filters)
    return runs


def get_run_data(run, metric_key="test/reward"):
    """Get timesteps and rewards from a WandB run."""
    history = run.scan_history(keys=["_step", metric_key])
    steps = []
    rewards = []
    for row in history:
        if metric_key in row:
            steps.append(row["_step"])
            rewards.append(row[metric_key])
    return np.array(steps), np.array(rewards)


def smooth_curve(x, y, window=5):
    """Smooth a curve using moving average."""
    if len(y) < window:
        return x, y
    cumsum = np.cumsum(np.insert(y, 0, 0))
    smoothed = (cumsum[window:] - cumsum[:-window]) / window
    return x[:len(smoothed)], smoothed


def plot_learning_curves(project: str, entity: str, output_path: str = "learning_curves.png"):
    """Plot learning curves for VPG and PPO from WandB."""
    
    print(f"Fetching runs from {entity}/{project}...")
    api = wandb.Api()
    
    try:
        runs = api.runs(f"{entity}/{project}")
    except Exception as e:
        print(f"Error fetching runs: {e}")
        return
    
    # Separate VPG and PPO runs
    vpg_runs = []
    ppo_runs = []
    
    for run in runs:
        if "VPG" in run.name:
            vpg_runs.append(run)
        elif "ppo" in run.name.lower():
            ppo_runs.append(run)
    
    print(f"Found {len(vpg_runs)} VPG runs and {len(ppo_runs)} PPO runs")
    
    fig, ax = plt.subplots(figsize=(10, 6))
    
    # Plot VPG runs
    for run in vpg_runs:
        try:
            steps, rewards = get_run_data(run, "test/reward")
            if len(steps) > 0:
                steps, rewards = smooth_curve(steps, rewards)
                ax.plot(steps, rewards, color='blue', alpha=0.3, linewidth=1)
        except Exception as e:
            print(f"Warning: Could not load run {run.name}: {e}")
    
    # Plot PPO runs
    for run in ppo_runs:
        try:
            steps, rewards = get_run_data(run, "test/reward")
            if len(steps) > 0:
                steps, rewards = smooth_curve(steps, rewards)
                ax.plot(steps, rewards, color='orange', alpha=0.3, linewidth=1)
        except Exception as e:
            print(f"Warning: Could not load run {run.name}: {e}")
    
    # Add legend
    ax.plot([], [], color='blue', label='VPG (value_steps=50)')
    ax.plot([], [], color='orange', label='PPO')
    ax.legend()
    
    ax.set_xlabel('Environment Steps')
    ax.set_ylabel('Evaluation Reward')
    ax.set_title('Learning Curves: VPG vs PPO')
    
    plt.tight_layout()
    plt.savefig(output_path, dpi=300, bbox_inches='tight')
    print(f"Saved chart to {output_path}")
    plt.close()


def plot_from_csv(output_path: str = "results/learning_curves.png"):
    """Plot learning curves from local CSV files generated by VPG and PPO scripts."""
    from pathlib import Path
    
    results_dir = Path("results")
    if not results_dir.exists():
        print(f"Results directory not found: {results_dir}")
        return
    
    # Find all learning curve files
    vpg_files = list(results_dir.glob("learning_curve_vpg_*.csv"))
    ppo_files = list(results_dir.glob("learning_curve_ppo_*.csv"))
    
    print(f"Found {len(vpg_files)} VPG files and {len(ppo_files)} PPO files")
    
    if not vpg_files and not ppo_files:
        print("No learning curve files found! Run experiments first.")
        return
    
    # Load all data
    all_data = []
    for f in vpg_files + ppo_files:
        try:
            df = pd.read_csv(f)
            all_data.append(df)
        except Exception as e:
            print(f"Error loading {f}: {e}")
    
    if not all_data:
        print("No data loaded!")
        return
    
    df = pd.concat(all_data, ignore_index=True)
    
    fig, ax = plt.subplots(figsize=(10, 6))
    
    # Group by algorithm and plot
    colors = {'VPG': 'blue', 'PPO': 'orange'}
    
    for algo in df['algorithm'].unique():
        algo_data = df[df['algorithm'] == algo]
        
        # Group by env and seed, then plot each run
        for (env, seed), run_data in algo_data.groupby(['env', 'seed']):
            run_data = run_data.sort_values('timestep')
            ax.plot(run_data['timestep'], run_data['reward'], 
                   color=colors.get(algo, 'gray'), alpha=0.5, linewidth=1)
    
    # Add legend entries
    for algo, color in colors.items():
        if algo in df['algorithm'].values:
            ax.plot([], [], color=color, label=algo, linewidth=2)
    
    ax.legend()
    ax.set_xlabel('Environment Steps (Timesteps)')
    ax.set_ylabel('Evaluation Reward')
    ax.set_title('Learning Curves: VPG vs PPO')
    ax.grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.savefig(output_path, dpi=300, bbox_inches='tight')
    print(f"Saved learning curves chart to {output_path}")
    plt.close()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Plot learning curves from WandB')
    parser.add_argument('--project', type=str, default='value-estimation-replication',
                       help='WandB project name')
    parser.add_argument('--entity', type=str, 
                       default='syedsaadhasanemad-iba-institute-of-business-administration',
                       help='WandB entity')
    parser.add_argument('--output', type=str, default='results/learning_curves.png',
                       help='Output path for chart')
    parser.add_argument('--from-csv', action='store_true',
                       help='Plot from local CSV instead of WandB')
    args = parser.parse_args()
    
    Path("results").mkdir(exist_ok=True)
    
    if args.from_csv:
        plot_from_csv(output_path=args.output)
    else:
        plot_learning_curves(args.project, args.entity, args.output)
